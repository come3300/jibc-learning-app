

{/* http://localhost:3000/documents/phase2/js-basic/second-step */}
<div class="bg-white">
    <div class="whitespace-nowrap mx-auto max-w-screen-md ">
    ## JavaScriptの基礎
    <img src="/phase1/website/hello-world/helloworld.png" loading="lazy" alt="Photo by Minh Pham" class="" />
  
    ### 値の種類と変数
    値（あたい）とは、プログラムの基本になるデータのことです。値にはいくつか種類があり、

    ```


    「数値」「文字列」「真偽値」「配列」「オブジェクト」「無」などがあります。
    種類	説明	書き方の例
    数値(Number)	数	100,1.5,5 + 8,10 - 3 * 6,1 / 2など
    文字列(String)	文字の羅列、テキスト	'hello',"こんにちは"など
    配列(Array)	いくつかの値の羅列	[1, 2, 3, 4, 5],['a', 'b', 'c']など
    真偽値(Boolean)	「正しい」「正しくない」のどちらか	true,falseの2つのみ
    無	なにもないことを表す	null,undefinedの2つのみ
    オブジェクト(Object)	名前と値の組み合わせ	one: 1, two: 2 など
    値は、すべてconsole.logで表示させることができます。いくつか例を見てみましょう。


    ```

    ```
    console.log(100) // 数値
    console.log('hello') // 文字列
    console.log([1, 2, 3, 4, 5]) // 配列
    console.log(true) // 真偽値
    console.log(null) // 無
    console.log({ one: 1, two: 2 }) // オブジェクト
    ```

    コード例について
    これ以降、明示しませんが、コード例は main.jsに記述する→ブラウザでindex.htmlをリロードする→コンソールに
    表示されている内容を見る という流れで毎回動作を確認してください。
    main.jsに記述している内容は、追記していってもよいですし、上書きしても構いません。Gitを使うと、
    上書きしても過去の内容を見返せるので便利でしょう。
    変数
    変数（定数）とは、値に名前をつける機能のことです。以下のように書きます。

    ```
    const 名前 = 値
    ```

    変数を宣言することによって、同じ値を何度も繰り返し活用でき、プログラマーが
    プログラムを見るだけでその値がなんの値か判別しやすくなります。
    また、変数を定義することを一般的に、変数を宣言するなどと呼びます
    では、42の値に変数名answerという名前で宣言してみてください。

    この例では、42という値に、answerという名前をつけています。また、このことを「**answer変数に42を代入する**」とも表現します。
    一度代入された変数は、コードの後の方で値と同じように使うことができます。
    では、変数answerをconsoleで出力した場合どうなるでしょう？

    console.logの出力結果
    これ以降、この講座では、console.logの出力結果を//=>のような表記で示します。例えば上記の例は、「console.log(answer)を実行すると、コンソールに42が表示される」という意味です。
    変数に代入できる値は、もちろん数値に限りません。代入の他の例を示します。

    ```
    const name = "Taro Yamada" // 文字列
    const isValid = true       // 真偽値
    const userIds = [1, 3, 10] // 配列

    console.log(name) //=> Taro Yamada
    console.log(isValid) //=> true
    console.log(userIds) //=> [1, 3, 10]
    ```

    変数名
    変数の名前（上記のname, isValid, userIdsなど）のことを「変数名」と言います。変数名に使える文字にはいくつか制約があります。
    * 最初の文字は必ずアルファベット(a-z, A-Z)、アンダースコア(_)、またはドル記号($)から始める
    * 2文字目以降は上記に加えて数字(0-9)が使用できる
    たとえば、total_count, UserProfile, $event, _tmpなどは正しい変数名です。
    一方、100times（数字から始まる）, this-is-test（使えない文字(-)を含む）,
    @name（使えない文字(@)を含む）などは変数名としては使えません。とくにハイフンが変数名として使えない文字であることは
    見落としがちなので注意してください。

    #### var/const/letの違い
    const以外にもvarやletを使って変数を定義することができます。それぞれ以下のような特徴があります。
        const	let	var
    再宣言	×	×	○
    再代入	×	○	○
    スコープ	ブロック	ブロック	関数
    ホイスティング	エラー	エラー	undefined
    基本的には
    * ほぼ全部constで定義できる
    * 数え上げのみlet
    * varはもう使わないぐらいに考えておきましょう。
    一般にconstで宣言した変数は再宣言も最代入も行えないことから定数と呼ばれます
    再宣言
    一度宣言した変数を、同じ変数名で宣言し直すことを再宣言といいます。
    再宣言可能なvarで再宣言した場合、後に宣言した変数が適用され、再宣言不可能なlet/constで再宣言した場合、
    エラーになります。varでは、予期しない再宣言が起こりうるため危険です。

    ```
    // var
    var a = 0;
    var a = 1;
    console.log(a) // `1`と出力される

    // let
    let b = 0;
    let b = 1; // SyntaxError: Identifier 'b' has already been declared

    // const
    const c = 0;
    const c = 1; // SyntaxError: Identifier 'c' has already been declared
    ```
    #### 再代入
    宣言した変数に値を設定し直すことを再代入といいます。再代入可能なvar/letで再代入した場合、
    値が再代入され、再代入不可能なconstで再代入した場合、エラーになります。

    ```
    // var
    var a = 0;
    a = 1;
    console.log(a) // `1`と出力される

    // let
    let b = 0;
    b = 1;
    console.log(b) // `1`と出力される

    // const
    const c = 0;
    c = 1; // Assignment to constant variable.
    ```

    文字列処理
    文字列は、JavaScriptでは特に多用されます。そのため、JavaScriptにはさまざま文字列を扱う方法が用意されています。
    文字列の値の書き方には、ここまで見てきたように単一引用符(')で囲む書き方と、
    二重引用符(")で囲む書き方の2種類があります。

    ```
    'これは文字列です'
    "これも文字列です"
    ```

    これらの書き方に差はほとんどありません。大きな違いは、'〜'なら文字列の中で"が使えること、
    逆に"〜"なら'が使えることです。
    よくある例は、英語のアポストロフィを書きたい場合です。もし'を使ってしまうと、

    ```
    'You're a JavaScript master!'
    ```

    というふうに、'You'の時点で文字列が「終わり」と解釈されてしまい、
    正しくない書き方としてエラーになってしまいます。
    

    ```
    "You're a JavaScript master!"
    ```

    と書くことができます。

    #### 文字列結合
    文字列と文字列は、+で繋げることができます。これを文字列結合と呼びます。

    ```
    const breakfast = "トースト"
    console.log("今日の朝ごはんは" + breakfast + "でした。") //=> 今日の朝ごはんはトーストでした。
    ```

    では、「今日の朝ごはんはお茶漬けでした。」と出力したい場合はどうすれば良いでしょう？

    #### テンプレート文字列
    上記のように+で文字を繋げると、少し記述が冗長です。バッククオート(`)で囲む特殊な書き方の文字列を使うと、
    もう少し簡単に書けます。

    ```
    const breakfast = "納豆ごはん"
    console.log(`今日の朝ごはんは${breakfast}でした。`) //=> 今日の朝ごはんは納豆ごはんでした。
    console.log(`8 + 7 = ${8 + 7}`) //=> 8 + 7 = 15
    ```

    $〜のところに、文字列の中に入れたい値や変数を書きます。この書き方の文字列をテンプレート文字列と呼びます。
    バッククオートの入力方法
    多くのキーボードでは、バッククオートはShift + @で入力できます。
    テンプレート文字列では、改行がそのまま書けるという特徴もあります（'や"で囲んだ文字列ではできません）。

    ```
    const html = `
    <div class="container">
    <p>test</p>
    </div>
    `

    console.log(html) //=> (略)
    ```
    #### 配列
    配列とは、いくつかの値の羅列をまとめて扱える値のことです。主に関係性のあるデータを複数扱うときに使います。
    例えば、40人の生徒の数学の点数のデータを使うとき、同じような変数を何個も作らなければなりません。
    しかし、配列を使うことによって一つの変数により、データを定義することができます。
    また、プログラムでは、関連したデータを扱うことが非常に多く出てきます。しっかりと覚えておきましょう。
    では、まずは曜日のデータを配列で定義してみましょう。

    ```
    const days = ['日', '月', '火', '水', '木', '金', '土']
    ```

    配列は[〜]の中に、値を,で区切って書きます。,の後は見やすくするために空白（スペース）を1つ書くのが普通ですが、
    無くてもエラーにはなりません。
    あるいは、以下のようにも書けます。

    ```
    const days = [
    '日',
    '月',
    '火',
    '水',
    '木',
    '金',
    '土', // ←ここに , を書いてもOK（書かなくてもOK）
    ]
    ```
    この書き方は、1行で書くと横が長くなりすぎるときによく使われます。

    ### 配列の情報
    配列は、いくつかの値をまとめるという性質上、これまでに見てきた値とは少し違った書き方が出てきます。
    ところで、配列の中に含まれる値のことを、配列の「要素」と呼ぶので、覚えておきましょう。
    配列の情報を調べる方法がいくつか用意されています。

    ```
    const days = ['日', '月', '火', '水', '木', '金', '土']

    // 配列の中の要素の数
    console.log(days.length) //=> 7

    // 配列の中の個別の要素
    console.log(days[0]) //=> 日
    console.log(days[1]) //=> 月
    console.log(days[2]) //=> 火
    console.log(days[3]) //=> 水
    console.log(days[4]) //=> 木
    console.log(days[5]) //=> 金
    console.log(days[6]) //=> 土
    console.log(days[7]) //=> undefined
    ```
    配列の中の要素を1つずつ「覗く」には、配列[インデックス]のような書き方をします。
    インデックスとは、配列の中の「何番目」であるかを表す数値です。ここで注意が必要なのが、
    インデックスは0から数えるという点です。日常生活では普通、数は1から数えるので、この違いには注意しましょう。
    最後のdays[7]では、undefinedと出力されます。直訳すると「定義されていない」という意味です。
    そのインデックスに要素が存在しないときは、undefinedになると覚えておきましょう。

    #### 配列の操作
    ```
    配列に要素を追加したり、削除したり、書き換えたりする方法も見ておきましょう。
    const nengou = ['明治', '大正', '昭和', '平成']

    // 配列に要素を「追加」する
    nengou.push('令和')

    console.log(nengou) //=> ['明治', '大正', '昭和', '平成', '令和']

    // 配列から要素を「削除」する
    nengou.splice(3, 1) // 3は削除したい要素のインデックス、1は削除したい要素の数

    console.log(nengou) //=> ['明治', '大正', '昭和', '令和']

    // 配列の特定の要素を直接書き換える
    nengou[2] = '昭和'

    console.log(nengou) //=> ['明治', '大正', '昭和', '令和']
    ```
    ### 条件分岐
    条件分岐とは、条件によってプログラムの流れを変えることです。
    JavaScriptでは条件分岐に「if文」を使います。以下が構文になります。
    基本形:

    ```
    if (条件) {
    条件が成り立ったときの処理
    } else {
    条件が成り立たなかったときの処理
    }
    ```
    いきなりプログラムで考えると難しく感じるので、現実世界と照らし合わせて考えてみましょう。
    例えば、ジャンケンで勝った方がおやつを一個多く食べれるとしましょう。
    * ジャンケンで勝ったの時（条件）、おやつ一個多く食べれる。（処理）
    * それ以外の時（条件）、おやつは食べれない。（処理）これが条件分岐です。
    思い返すと、人生は条件分岐の繰り返しです。なので、シンプルに考えるとそれほど難しいものではないのです。
    そしてまた、プログラムも条件分岐の繰り返しです。しっかりここで理解していきましょう！

    例:

    ```
    const num = Math.random() // 0.0〜1.0の数値をランダムに作る

    if (num >= 0.5) {
    console.log('大きめ')
    } else {
    console.log('小さめ')
    }

    console.log(`数: ${num}`)
    ```

    このプログラムを何回か実行してみてください（何回かページをリロードしてください）。
    実行するたびに、「大きめ」「小さめ」が五分五分くらいの確率でコンソールに表示されます。
    まず、最初のMath.random()という書き方は見慣れないものですが、0.0〜1.0の間のランダムな数値が作られる、
    とイメージしてください。条件分岐は毎回違う値を比べないと動作確認ができないので、そのような値を作るために使っています。
    条件の部分にはnum >= 0.5と書かれています。これは「numが0.5以上」という条件を表しています。
    条件が成り立ったとき、つまり「numが0.5以上」のときは、if (条件) 〜の間に書かれたプログラムが実行されます。
    一方、成り立たなかったとき、つまり「numが0.5未満」のときは、else 〜に書かれたプログラムは実行されます。
    このように、if文を使うと、プログラムの流れを条件によって切り替えることができます。
    また、最後にかならず「数: 0.2」のように表示される点に注目してください。分岐したプログラムは、
    if文の部分が終わると合流して、再び一本の流れのように実行されます。

   #### 真偽値
    真偽値（しんぎち）とは、条件が成り立つか、成り立たないかを表す値のことです。
    具体的には、「成り立つ」を表す値をtrue、「成り立たない」を表す値をfalseと書きます。
    普段はあまりこのような書き方はしませんが、if文の条件に直接trueやfalseを書いて、
    真偽値の効果をわかりやすくしてみましょう。

    ```
    if (true) {
    console.log('必ずこちらが実行される')
    } else {
    console.log('こちらは実行されない')
    }

    if (false) {
    console.log('今度はこちらが実行されない')
    } else {
    console.log('こちらが実行される')
    }
    ```

    実際は、何らかの処理の結果がtrueかfalseという値になり、それをif文の条件に書く、という使い方をします。

    ```
    const result = 何らかの処理
    // resultにはtrueかfalseが代入される

    if (result) {
    // ...
    } else {
    // ...
    }
    ```
    条件式の書き方
    最初の例では「以上」という条件を表すのに>=という記号を使っていますが、
    条件の書き方には、他にも以下のバリエーションがあります。

    ```

    a === b: aとbが同じときtrue
    a !== b: aとbが違うときtrue
    a < b: aがbより小さい（未満）ときtrue
    a <= b: aがb以下のときtrue
    a > b: aがbより大きいときtrue
    a >= b: aがb以上のときtrue
    
     ```
    このうち、===と!==は、任意の種類の値に対して利用できます。一方、それ以外は数値に対してのみ利用できる書き方です。
    ==と===
    ここでは===という書き方を紹介しましたが、実はJavaScriptには==という書き方もあり、
    どちらも「同じ」という条件を表します。
    ここでは詳しく説明しませんが、==と===では微妙に比較の結果が異なる場合があり、
    ==の結果はやや直感に反するため、現在はほとんど使われません。基本は===を使うと覚えておきましょう。
    もしかしたら、古いコードを読むときに==に出会うことがあるかもしれません。
    また、条件と条件を組み合わせて、別の条件にすることも可能です。
    * A && B: Aがtrue、かつ、Bもtrueのときtrue
    * A || B: Aがtrue、または、Bがtrueのときtrue
    * !A: Aがfalseのときtrue
    具体例をいくつか見て、イメージを掴みましょう。

    ```
    
    const a = 2
    const b = 3
    console.log(a === b) //=> false
    console.log(a !== b) //=> true
    console.log(a < b) //=> true
    console.log(a <= b) //=> true
    console.log(a > b) //=> false
    console.log(a >= b) //=> false

    const c = 10
    const d = 2 * 5
    console.log(c === d) //=> true
    console.log(c !== d) //=> false
    console.log(c < d) //=> false
    console.log(c <= d) //=> true
    console.log(c > d) //=> false
    console.log(c >= d) //=> true

    console.log(a === b && c === d) //=> false
    console.log(a === b || c === d) //=> true
    console.log(!(a === b)) //=> false

    ```
    #### else if
    後から追加した内容のため動画に反映されていません。ご不便おかけして申し訳ございませんが、何かわからないことがあれば、個別指導にお越しください
    条件分岐は、続けていくつも書くことができます。これにはelse ifという書き方を使います。「そうでなくてもし〜なら」という意味になります。
    例: 成績判定プログラム
    ```
    const score = Math.random() * 100 // 0.0〜100.0の間の数値をランダムに作る

    console.log(`点数: ${score}`)

    if (score >= 90) {
    console.log('秀')
    } else if (score >= 75) {
    console.log('優')
    } else if (score >= 60) {
    console.log('良')
    } else if (score >= 30) {
    console.log('可')
    } else {
    console.log('不可')
    }
    ```
    #### ループ
    if文によって処理の流れを分岐できることを学びましたが、ある処理を何度も繰り返す方法も存在します。
    このような繰り返しのことをループと呼びます。
    JavaScriptには、ループの書き方がいくつか用意されています。代表的なものは、for文、while文、forEachです。
    #### for文
    for文は、特定の回数繰り返すのによく使われる書き方です。
    基本形:
    ```
    for (let 変数 = 0; 変数 < 繰り返し回数; 変数++) {
    繰り返したい処理
    }
    ```
    例: 0から9までの数値を表示
    ```
    for (let i = 0; i < 10; i++) {
    console.log(i)
    }
    ```
    ここで、console.logを1回しか書いていないことに注目してください。にも関わらず、
    出力は10回表示されています。これがループの力です。
    for文の一般形
    実は上記はfor文の書き方の一例でしかありません。より一般的な形で書くと以下のようになります。

    ```
    for (初期化処理; 条件; 更新処理) {
    繰り返したい処理
    }
    ```
    #### while文
    while文は、ある条件を満たすまでループを続けたいという場合によく使われる書き方です。if文と似た書き方をします。
    基本形:
    ```
    while (ループを続ける条件) {
    繰り返したい処理
    }
    ```
    例:
    ```
    let s = 2 // letは「あとで書き換えできる（代入し直せる）」変数

    while (s < 100000) {
    console.log(s)
    s = s * s
    }
    ```
    この例では、s * sでsをどんどん二乗していって、sが100000を超えたところで繰り返しを打ち切ります。
    #### 関数
    関数（かんすう）とは、処理を使いまわせるようにまとめたもののことです。
    イメージとしては、料理の「レシピ」のようなものです。レシピは一度作ってしまえばそれを毎回の料理に
    何度でも使い回せるように、関数も一度作れば何度でも同じ処理を使い回すことができます。
    関数の作り方
    まず、関数の作り方の具体例を見ていきましょう。
    レシピと料理の例で言えば、まずレシピを作ることにあたります。
    ```
    function cook(food1, food2) {
    console.log(food1 + 'を切ります。')
    console.log(food1 + 'を炒めます。')
    console.log(food2 + 'をすりおろします。')
    console.log(food1 + 'に' + food2 + 'を混ぜます。')
    }
    ```
    関数には名前をつけられます（「●●料理のレシピ」のようなものです）。
    この例ではcookの部分が名前にあたります。なお、関数の名前を「関数名」と呼びます。
    food1やfood2については後述します。
    ~の間に、まとめたい処理を書きます。この例ではconsole.logしか書いていませんが、
    ここには（ほぼ）任意のJavaScriptのコードを書くことができます。
    関数を作ることを、「関数を定義する」とも言います。この例で言えば、「cook関数を定義」していることになります。
    レシピを作っただけでは料理はできないように、関数を定義しただけでは、処理は実行されない点に注意してください。
    たとえば、上記のコードだけをmain.jsに記載して実行しても、コンソールには何も表示されません。
    
    #### 関数の使い方
    次に、上記で作った関数を使ってみましょう。関数を使うことを、「関数を呼び出す」とも言います。
    レシピと料理の例で言えば、レシピに沿って実際に料理を作ることにあたります。
    関数を呼び出すには、以下のように関数名(...)のように関数名のあとにカッコを書きます。

    ```
    // ※この前に上記のfunction〜を記述しておく

    cook('豚肉', '生姜')
    ```

    '豚肉'や'生姜'の部分を引数（ひきすう）といいます。
    引数は、関数の「呼び出しごとに違う部分」を穴埋めするようなイメージです。レシピの例で言えば、「お好みの調味料」と書かれているようなもので、そこで「塩コショウ」を選ぶか「マヨネーズ」を選ぶか「ケチャップ」を選ぶかは毎回の料理で変えることができる、というのと同じようなものです。
    引数をいくつ書くことができるかは、呼び出す関数次第です。例えばcook関数の定義には(food1, food2)のように書いてありますが、これは「cookを呼び出すときに引数は2つ書くことができる、それらの引数は関数の中ではfood1とfood2と書くと使える」ということを表しています。
    引数の例をいくつか見ていきましょう。たとえば、
    ```
    function foo(a, b, c) {
    console.log(`fooが引数${a}, ${b}, ${c}で呼び出された`)
    }

    function bar() {
    console.log('barが呼び出された')
    }
    ```
    のように定義されていれば、foo関数を呼び出すときは引数は3つ書くことができ、
    bar関数を呼び出すときは1つも引数を書くことができません（このような関数を「ゼロ引数関数」と言うこともあります）。
    呼び出し例:
    ```
    foo(1, 'abc', true) //=> fooが引数1, abc, trueで呼び出された
    bar() //=> barが呼び出された
    ```
    #### 関数の戻り値
    関数は、処理の結果の値を、呼び出した側に返すことができます。この値のことを戻り値（もどりち）と呼びます。
    関数から戻り値を返すには、returnという書き方を使います。
    例: 消費税を計算する
    ```
    function applyTax(price) {
    const result = price * 0.1 // 消費税率は10%
    return result
    }

    const tax = applyTax(12000)
    console.log(tax) //=> 1200
    ```
    ハイライトした行に注目してください。まず、関数の中ではreturnという書き方で、resultを戻り値にしています。
    次に、関数を呼び出した側では、applyTax(12000)の戻り値をtax変数に代入します。
    これにより、関数の中の処理の結果を受け取ることができます。
    #### アロー関数
    関数の書き方には、いくつか細かいバリエーションがあります。完全にここで覚えなくてもよいですが、
    「このような書き方がある」というのは頭の片隅に置いておきましょう。
    まず、ここまで学習した書き方でdoubleという関数を定義します。引数を2倍にして返すだけの関数です。
    ```
    function double(x) {
    return x * 2
    }
    ```
    これは、以下のようにも書けます。このような=>を使った書き方を「アロー関数」とも呼びます。
    ```
    const double = (x) => {
    return x * 2
    }
    ```
    アロー関数の書き方のときに限り、引数が1つだけの場合は、()を省略することができます。
    ```
    const double = x => {
    return x * 2
    }
    ```
    さらに、アロー関数の書き方のときに限り、関数の中身がreturnだけのときは、{}を省略することができます。
    ```
    const double = x => x * 2
    ```

    #### スコープ

    実行中のコードから参照できる範囲をスコープといいます。const/letはブロックスコープ({}で囲われた部分
    - if文やfor文など)が適用されますが、varはブロックスコープが適用されません。※ 関数スコープ(関数宣言の{})は、
    var/const/letすべてに適用されます。
    ```
    /*
    * var
    */
    {
    var a = 0;
    }
    // ブロックスコープが適用されないため、ブロック外でも値の参照が可能
    console.log(a); // 0


    /*
    * let
    */
    {
    // ブロックスコープにより、再宣言にならない。
    let a = 1;
    console.log(a); // 1
    }
    // letはブロックスコープであり参照できないため、varで宣言した値が参照される。
    console.log(a); // 0

    /*
    * const
    */
    {
    const b = 2;
    console.log(b); //2
    }
    console.log(b) // b is not defined
    ```

    </div>
</div>